<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>test_advanced.py - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/darkfish.js"></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../Makefile.html">Makefile</a>
  
    <li><a href="../README_md.html">README</a>
  
    <li><a href="../auteur.html">auteur</a>
  
    <li><a href="../cmd_pipe_sh.html">cmd_pipe.sh</a>
  
    <li><a href="../libsrcs/ft_printf/Makefile.html">Makefile</a>
  
    <li><a href="../libsrcs/ft_printf/auteur.html">auteur</a>
  
    <li><a href="../libsrcs/libft/Makefile.html">Makefile</a>
  
    <li><a href="../libsrcs/libft/auteur.html">auteur</a>
  
    <li><a href="../lsappinfo.html">lsappinfo</a>
  
    <li><a href="../makebordel.html">makebordel</a>
  
    <li><a href="../notes.html">notes</a>
  
    <li><a href="../poulet.html">poulet</a>
  
    <li><a href="../tests/__init___py.html">__init__.py</a>
  
    <li><a href="../tests/test_advanced_py.html">test_advanced.py</a>
  
    <li><a href="../tests/test_basics_py.html">test_basics.py</a>
  
    <li><a href="../todo.html">todo</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page tests/test_advanced.py">

<p>import os import subprocess import unittest</p>

<p>BINARY_NAME = “21sh”</p>

<p>class TestBasics(unittest.TestCase):</p>

<pre>tests_dir = os.path.split(__file__)[0]
binary = &quot;%s/../%s&quot; % (tests_dir, BINARY_NAME)
prompt = &quot;&quot;

@classmethod
def setUpClass(cls):
    os.write(1, &quot;\nRunning %s\n&quot; % __file__)
    if os.path.isfile(cls.binary) is False:
        raise IOError(&quot;Make the project: %s not here\n&quot; % cls.binary)
    cls.prompt = cls.get_prompt(cls.binary)

@classmethod
def tearDownClass(cls):
    os.write(1, &quot;\n&quot;)

@staticmethod
def get_prompt(binary):
    cmd_list = [&quot;/bin/echo&quot;, &quot;-n&quot;]
    p_command = subprocess.Popen(cmd_list, stdout=subprocess.PIPE)
    p_minishell = subprocess.Popen(
        [&quot;%s&quot; % binary], stdin=p_command.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    p_command.stdout.close()
    stdout, stderr = p_minishell.communicate()
    return stdout

def execute_my_shell(self, command):
    &quot;&quot;&quot;
    Here my shell
    :param command: list of command like [&quot;/bin/ls&quot;, &quot;-l&quot;]
    :return: 
    &quot;&quot;&quot;
    cmd_list = [&quot;/bin/echo&quot;, &quot;-n&quot;] + command
    p_command = subprocess.Popen(cmd_list, stdout=subprocess.PIPE)
    p_minishell = subprocess.Popen(
        [&quot;%s&quot; % self.binary], stdin=p_command.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    p_command.stdout.close()
    stdout, stderr = p_minishell.communicate()

    stdout = stdout.replace(&quot;%s\n&quot; % self.prompt, &quot;&quot;)
    stdout = stdout.replace(&quot;%s&quot; % self.prompt, &quot;&quot;)

    return stdout, stderr

@staticmethod
def execute_real_shell(command):
    &quot;&quot;&quot;
    Here the real shell
    :param command: list of command like [&quot;/bin/ls&quot;, &quot;-l&quot;]
    :return: 
    &quot;&quot;&quot;
    cmd_list = [&quot;/bin/echo&quot;] + command
    p_command = subprocess.Popen(cmd_list, stdout=subprocess.PIPE)
    p_real_shell = subprocess.Popen(
        [&quot;/bin/bash&quot;], stdin=p_command.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    p_command.stdout.close()
    stdout, stderr = p_real_shell.communicate()
    return stdout, stderr.replace(&quot;/bin/bash: line 1: &quot;, &quot;&quot;)  # because of bash piping

def compare_shells(self, command):
    real_std = self.execute_real_shell(command)
    my_std = self.execute_my_shell(command)
    self.assertEqual(real_std, my_std)

def test_00_prompt_is_removed(self):
    stdout, stderr = self.execute_my_shell([&quot;&quot;])
    self.assertEqual(&quot;&quot;, stdout)
    self.assertEqual(&quot;&quot;, stderr)

def test_semi_00(self):
    self.compare_shells([&quot;ls&quot;, &quot;;&quot;, &quot;ls&quot;])

def test_pipe_00(self):
    self.compare_shells([&quot;ls&quot;, &quot;|&quot;, &quot;cat -e&quot;])

def test_pipe_01(self):
    self.compare_shells([&quot;ls&quot;, &quot;|&quot;, &quot;cat -e&quot;, &quot;|&quot;, &quot;sort&quot;])

def test_pipe_02(self):
    self.compare_shells([&quot;ls&quot;, &quot;|&quot;, &quot;cat -e&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;rev&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;cat -e&quot;])

def test_pipe_03(self):
    self.compare_shells([&quot;ls&quot;, &quot;|&quot;, &quot;cat -e&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;rev&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;cat -e&quot;,
                         &quot;|&quot;, &quot;cat -e&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;rev&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;cat -e&quot;])

def test_pipe_04(self):
    self.compare_shells([&quot;ls&quot;, &quot;|&quot;, &quot;cat -e&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;rev&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;cat -e&quot;,
                         &quot;|&quot;, &quot;cat -e&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;rev&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;|&quot;, &quot;cat -e&quot;,
                         &quot;|&quot;, &quot;cat -e&quot;, &quot;|&quot;, &quot;cat -e&quot;])

def test_right_00(self):
    out = &quot;out&quot;
    self.compare_shells([&quot;ls&quot;, &quot;&gt;&quot;, &quot;%s&quot; % out])
    os.remove(out)

def test_right_01(self):
    my_out = &quot;out.my&quot;
    ref_out = &quot;out.ref&quot;
    for f in [my_out, ref_out]:
        with open(f, &#39;w&#39;) as fd:
            fd.write(&quot;&quot;)
    self.execute_my_shell([&quot;ls&quot;, &quot;&gt;&quot;, &quot;%s&quot; % my_out])
    self.execute_real_shell([&quot;ls&quot;, &quot;&gt;&quot;, &quot;%s&quot; % ref_out])
    with open(my_out, &#39;r&#39;) as my:
        with open(ref_out, &#39;r&#39;) as ref:
            self.assertEqual(ref.read(), my.read())
    for f in [my_out, ref_out]:
        os.remove(f)

def test_right_02(self):
    my_out = &quot;out.my&quot;
    ref_out = &quot;out.ref&quot;
    for f in [my_out, ref_out]:
        with open(f, &#39;w&#39;) as fd:
            fd.write(&quot;&quot;)
    self.execute_my_shell([&quot;ls&quot;, &quot;&gt;&quot;, &quot;%s&quot; % my_out])
    self.execute_my_shell([&quot;ls&quot;, &quot;&gt;&gt;&quot;, &quot;%s&quot; % my_out])
    self.execute_real_shell([&quot;ls&quot;, &quot;&gt;&quot;, &quot;%s&quot; % ref_out])
    self.execute_real_shell([&quot;ls&quot;, &quot;&gt;&gt;&quot;, &quot;%s&quot; % ref_out])
    with open(my_out, &#39;r&#39;) as my:
        with open(ref_out, &#39;r&#39;) as ref:
            self.assertEqual(ref.read(), my.read())
    for f in [my_out, ref_out]:
        os.remove(f)

def test_right_03(self):
    my_out = &quot;out.my&quot;
    ref_out = &quot;out.ref&quot;
    for f in [my_out, ref_out]:
        with open(f, &#39;w&#39;) as fd:
            fd.write(&quot;&quot;)
    self.execute_my_shell([&quot;ls&quot;, &quot;&gt;&quot;, &quot;%s&quot; % my_out])
    self.execute_my_shell([&quot;ls&quot;, &quot;&gt;&gt;&quot;, &quot;%s&quot; % my_out])
    self.execute_my_shell([&quot;ls&quot;, &quot;&gt;&quot;, &quot;%s&quot; % my_out])
    self.execute_real_shell([&quot;ls&quot;, &quot;&gt;&quot;, &quot;%s&quot; % ref_out])
    self.execute_real_shell([&quot;ls&quot;, &quot;&gt;&gt;&quot;, &quot;%s&quot; % ref_out])
    self.execute_real_shell([&quot;ls&quot;, &quot;&gt;&quot;, &quot;%s&quot; % ref_out])
    with open(my_out, &#39;r&#39;) as my:
        with open(ref_out, &#39;r&#39;) as ref:
            self.assertEqual(ref.read(), my.read())
    for f in [my_out, ref_out]:
        os.remove(f)

def test_left_00(self):
    my_in = &quot;in.my&quot;
    with open(my_in, &#39;w&#39;) as fd:
        fd.write(&quot;data&quot;)
    self.compare_shells([&quot;cat&quot;, &quot;&lt;&quot;, &quot;%s&quot; % my_in])
    os.remove(my_in)

def test_left_pipe_00(self):
    my_in = &quot;in.my&quot;
    with open(my_in, &#39;w&#39;) as fd:
        fd.write(&quot;data&quot;)
    self.compare_shells([&quot;cat&quot;, &quot;&lt;&quot;, &quot;%s&quot; % my_in, &quot;|&quot;, &quot;cat -e&quot;])
    os.remove(my_in)

def test_left_pipe_01(self):
    my_in = &quot;in.my&quot;
    with open(my_in, &#39;w&#39;) as fd:
        fd.write(&quot;3\n2\n1\n&quot;)
    self.compare_shells([&quot;cat&quot;, &quot;&lt;&quot;, &quot;%s&quot; % my_in, &quot;|&quot;, &quot;cat -e&quot;, &quot;|&quot;, &quot;sort&quot;])
    os.remove(my_in)

def test_left_pipe_right_00(self):
    data_in = &quot;in.my&quot;
    my_out = &quot;out.my&quot;
    ref_out = &quot;out.ref&quot;
    for f in [my_out, ref_out]:
        with open(f, &#39;w&#39;) as fd:
            fd.write(&quot;&quot;)
    with open(data_in, &#39;w&#39;) as fd:
        fd.write(&quot;3\n2\n1\n&quot;)

    def cli(output):
        return [&quot;cat&quot;, &quot;&lt;&quot;, &quot;%s&quot; % data_in, &quot;|&quot;, &quot;cat -e&quot;, &quot;|&quot;, &quot;sort&quot;, &quot;&gt;&quot;, &quot;%s&quot; % output]

    self.execute_my_shell(cli(my_out))
    self.execute_real_shell(cli(ref_out))

    with open(my_out, &#39;r&#39;) as my:
        with open(ref_out, &#39;r&#39;) as ref:
            # self.assertEqual(ref.read(), my.read())
            # TODO fix me
            pass
    for f in [data_in, my_out, ref_out]:
        os.remove(f)</pre>

<p>if __name__ == “__main__”:</p>

<pre class="ruby"><span class="ruby-identifier">unittest</span>.<span class="ruby-identifier">main</span>()
</pre>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

